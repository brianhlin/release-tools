#!/bin/bash

# Unlock the release repos and move the pre-release packages into them.
# Create a version-specific release tag
# Lock and regenerate the release repos
# Write release notes and update information on UW's AFS

. release-common.sh
detect_rescue_file

if [[ ! -d /p/vdt/public/html/release-info/ && $DRY_RUN -eq 0 ]]; then
    print_header "Not on UW's AFS..."
    print_header "Enter username and machine name to use for scp (e.g. matyas@ingwe.cs.wisc.edu):"
    read rusermachine
fi

for ver in ${versions[@]}; do
    branch=$(osg_release $ver)
    if [[ $branch == 'upcoming' ]]; then
        ver=$upcoming_version
    fi
    read -ra dvers <<< $(osg_dvers $ver) # create array of dvers
    for dver in ${dvers[@]}; do
        prerelease_repo=osg-$branch-$dver-prerelease
        release_repo=osg-$branch-$dver-release

        # Push from pre-release to release
        print_header "Unlocking $release_repo"
        run_cmd "osg-koji edit-tag --unlock $release_repo"
        echo

        print_header "Moving packages from $prerelease_repo to $release_repo"
        run_cmd "osg-koji list-tagged --quiet $prerelease_repo | awk '{print \$1}' > move-to-$branch-release-$dver"
        run_cmd "xargs --arg-file move-to-$branch-release-$dver osg-koji move-pkg $prerelease_repo $release_repo"
        echo

        # Create new release repo
        versioned_release_repo=osg-$branch-$dver-release-$ver
        print_header "Cloning $release_repo to $versioned_release_repo"
        run_cmd "osg-koji clone-tag $release_repo $versioned_release_repo"
        echo

        # Lock repos
        print_header "Locking $release_repo"
        run_cmd "osg-koji edit-tag --lock $release_repo"
        echo
        print_header "Locking $versioned_release_repo"
        run_cmd "osg-koji edit-tag --lock $versioned_release_repo"
        echo

        # Regen repos
        print_header "Regenerating $versioned_release_repo"
        run_cmd "osg-koji regen-repo --nowait $versioned_release_repo"
        echo

        # Write release notes
        awk '{ print "   * [[https://koji-hub.batlab.org/koji/search?match=glob&type=build&terms=" $1 "][" $1 "]]"}' move-to-$branch-release-$dver > $branch-release-note-packages-$dver
        xargs --arg-file move-to-$branch-release-$dver osg-koji buildinfo | fgrep "/mnt" | xargs -n 1 basename | perl -p -e "s/\.(noarch|src|i386|x86_64)\.rpm//" | sort -u > $branch-release-note-rpms-$dver
        if [[ $branch == 'upcoming' ]]; then
            list-package-updates -u $ver > $branch-release-note-rpm-updates-$dver
        else
            list-package-updates $ver > $branch-release-note-rpm-updates-$dver
        fi

        # Update info
        run_cmd "cp move-to-$branch-release-$dver $ver-updated-$branch-$dver.txt"
        run_cmd "osg-koji list-tagged --quiet --latest $release_repo | awk '{print \$1}' > $ver-packages-$branch-$dver.txt"
        run_cmd "xargs --arg-file $ver-packages-$branch-$dver.txt osg-koji buildinfo | fgrep \"/mnt\" | xargs -n 1 basename | sort > $ver-rpms-$branch-$dver.txt"
        echo
    done
done

# Copy release info files over to AFS
release_files=awk '/\.txt$/ {print $NF}' $rescue_file
print_header "Copying files over to UW's AFS"
if [ -d /p/vdt/public/html/release-info/ ]; then
    run_cmd "cp $release_files /p/vdt/public/html/release-info/"
else
    run_cmd "scp $release_files $rusermachine:/p/vdt/public/html/release-info/"
fi

# Don't remove rescue files if user is troubleshooting
if [ $DRY_RUN -eq 0 ]; then
    cleanup_on_success
fi
